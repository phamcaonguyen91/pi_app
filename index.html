<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C·ªù T∆∞·ªõng 2D - Mobile Friendly</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://sdk.minepi.com/pi-sdk.js"></script>
    <style>
        /* Thi·∫øt l·∫≠p font cho c√°c qu√¢n c·ªù b·∫±ng Unicode/Emoji, ƒë·∫£m b·∫£o hi·ªÉn th·ªã ƒë·∫πp v√† s·∫Øc n√©t */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            /* Thay ƒë·ªïi ƒë·ªÉ cƒÉn gi·ªØa v√† s·ª≠ d·ª•ng to√†n b·ªô kh√¥ng gian m√†n h√¨nh */
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* B·∫Øt ƒë·∫ßu t·ª´ tr√™n xu·ªëng */
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
        }

        .chess-container {
            background-color: #fff;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 15px; /* Gi·∫£m padding cho mobile */
            max-width: 95vw;
            width: 450px; /* Chi·ªÅu r·ªông t·ªëi ƒëa */
        }

        .board {
            display: grid;
            /* B√†n c·ªù C·ªù T∆∞·ªõng c√≥ 9 c·ªôt v√† 10 h√†ng */
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(10, 1fr);
            width: 100%;
            aspect-ratio: 9 / 10; /* Gi·ªØ t·ª∑ l·ªá chu·∫©n 9x10 */
            background: #d4a373; /* M√†u g·ªó nh·∫°t */
            border: 5px solid #6f4c3b;
            box-sizing: border-box;
            position: relative;
        }

        .square {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            cursor: pointer;
            z-index: 10;
        }
        
        /* V·∫Ω c√°c ƒë∆∞·ªùng k·∫ª ngang v√† d·ªçc */
        .square:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 1px solid #6f4c3b;
            box-sizing: border-box;
            z-index: -1;
        }

        /* X√≥a ƒë∆∞·ªùng k·∫ª b√™n trong, ch·ªâ gi·ªØ l·∫°i ƒë∆∞·ªùng k·∫ª √¥ */
        .square:not(:nth-child(9n)):before { border-right: none; }
        .square:nth-child(n+1):nth-child(-n+9):before { border-top: none; }
        .square:nth-last-child(n+1):nth-last-child(-n+9):before { border-bottom: none; }
        .square:nth-child(9n):before { border-right: none; }
        
        /* X√≥a ƒë∆∞·ªùng k·∫ª gi·ªØa s√¥ng */
        .square:nth-child(n + 37):nth-child( -n + 45):before { border-bottom: none; } /* H√†ng 4 */
        .square:nth-child(n + 46):nth-child( -n + 54):before { border-top: none; } /* H√†ng 5 */

        /* Hi·ªÉn th·ªã S√¥ng (River) */
        .river {
            position: absolute;
            top: 45%;
            left: 0;
            width: 100%;
            height: 10%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5vmin; /* D√πng vmin ƒë·ªÉ co gi√£n theo m√†n h√¨nh */
            font-weight: bold;
            color: #6f4c3b;
            background-color: #f7e0c4;
            pointer-events: none;
            z-index: 5;
            text-shadow: 1px 1px 1px #fff;
        }
        .river-text {
            /* V·ªã tr√≠ c·ªßa H√† */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4vmin; /* D√πng vmin ƒë·ªÉ co gi√£n theo m√†n h√¨nh */
            color: #6f4c3b;
            z-index: 10;
        }

        /* Qu√¢n c·ªù */
        .piece {
            width: 90%; /* TƒÉng k√≠ch th∆∞·ªõc qu√¢n c·ªù cho d·ªÖ ch·∫°m */
            height: 90%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5vmin; /* D√πng vmin ƒë·ªÉ co gi√£n theo m√†n h√¨nh */
            font-weight: 700;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
        }

        .red {
            background-color: #fce8e8;
            color: #c0392b;
            border: 2px solid #c0392b;
        }

        .black {
            background-color: #e8e8f2;
            color: #2c3e50;
            border: 2px solid #2c3e50;
        }

        /* Tr·∫°ng th√°i */
        .selected {
            transform: scale(1.15); /* TƒÉng scale khi ch·ªçn cho d·ªÖ nh√¨n tr√™n mobile */
            box-shadow: 0 0 10px 4px #f39c12;
            z-index: 20;
        }

        /* FIX L·ªñI CO GI√ÉN √î C·ªú: D√πng outline thay cho border */
        .highlight-move {
            outline: 4px dashed #27ae60;
            outline-offset: -2px; /* D·ªãch v√†o trong 2px ƒë·ªÉ vi·ªÅn ƒë·∫πp h∆°n */
            background-color: rgba(39, 174, 96, 0.2);
        }
        
        /* CSS cho Modal (thay th·∫ø cho alert) */
        #message-modal {
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            visibility: hidden;
        }
        #message-modal.active {
            opacity: 1;
            visibility: visible;
        }
        /* Style cho ƒë·ªãa ch·ªâ v√≠ c√≥ th·ªÉ copy */
        .wallet-address-copy {
            cursor: pointer;
            position: relative;
        }
        .wallet-address-copy:hover .copy-icon {
            opacity: 1;
        }
        .copy-icon {
            opacity: 0.5;
            transition: opacity 0.2s;
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <div class="chess-container">
        
        <div class="text-center mb-4">
            <h1 class="text-xl sm:text-2xl font-bold text-gray-800" data-i18n="gameTitle">C·ªù T∆∞·ªõng 2D</h1>
            <p id="status" class="text-sm sm:text-lg font-semibold mt-2 rounded-lg py-1 px-3 inline-block bg-yellow-100 text-yellow-700 shadow-md"></p>
        </div>

        <div class="board" id="board">
            <div class="river"><span class="river-text" data-i18n="riverName">S√¥ng H√†</span></div>
        </div>

        <div class="mt-4 flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4 w-full">
            <button id="reset-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-300 text-base" data-i18n="resetButton">
                Ch∆°i L·∫°i
            </button>
            <button id="donate-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-300 text-base" data-i18n="donateButton">
                ·ª¶ng h·ªô 1 Pi
            </button>
        </div>
        
        <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4">
            <div class="bg-white p-6 rounded-xl shadow-2xl max-w-xs w-full">
                <h3 id="modal-title" class="text-xl font-bold mb-3 text-gray-800" data-i18n="modalTitle">Th√¥ng b√°o</h3>
                <div id="modal-content" class="text-gray-700 mb-4 text-sm break-words overflow-y-auto max-h-64"></div>
                <button id="modal-custom-action" class="hidden w-full text-white font-bold py-2 px-4 rounded-lg transition duration-200 mb-3"></button>
                <button id="modal-close" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200" data-i18n="closeButton">ƒê√≥ng</button>
            </div>
        </div>
    </div>

    <script>
        // ----------------------------------------------------
        // C·∫•u h√¨nh & Kh·ªüi t·∫°o
        // ----------------------------------------------------
        
        // **ƒê·ªäA CH·ªà V√ç C·ª¶A B·∫†N (S·ª¨A L·∫†I ƒê·ªäA CH·ªà N√ÄY)**
        const PI_WALLET_ADDRESS = 'GBML46SIXNWSYMDJNHPA5CJ4LT65EBJF66HZ26VFPQ3R64EKB7EGYC2P';
        
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('reset-button');
        const donateButton = document.getElementById('donate-button');
        
        const modalElement = document.getElementById('message-modal');
        const modalTitleElement = document.getElementById('modal-title');
        const modalContentElement = document.getElementById('modal-content');
        const modalCloseButton = document.getElementById('modal-close');
        const modalCustomButton = document.getElementById('modal-custom-action'); 
        
        const BOARD_SIZE = 90; // 9 c·ªôt x 10 h√†ng

        // D·ªØ li·ªáu ng√¥n ng·ªØ
        const translations = {
            'vi': {
                gameTitle: 'C·ªù T∆∞·ªõng 2D',
                riverName: 'S√¥ng H√†',
                resetButton: 'Ch∆°i L·∫°i',
                donateButton: '·ª¶ng h·ªô 1 Pi',
                modalTitle: 'Th√¥ng b√°o',
                closeButton: 'ƒê√≥ng',
                restartConfirm: 'B·∫°n c√≥ mu·ªën kh·ªüi ƒë·ªông l·∫°i tr√≤ ch∆°i v·ªõi c·∫•p ƒë·ªô m·ªõi?', 
                // Th√™m cho Startup Modal
                startupTitle: 'Ch·ªçn C·∫•u h√¨nh Tr√≤ ch∆°i',
                startGameButton: 'B·∫Øt ƒê·∫ßu Ch∆°i',
                diffLevel: 'ƒê·ªô kh√≥ AI:',
                // C·∫•p ƒë·ªô kh√≥
                diffEasy: 'D·ªÖ',
                diffMedium: 'Trung b√¨nh',
                diffHard: 'Kh√≥',
                // Tr·∫°ng th√°i game
                statusRedTurn: 'L∆∞·ª£t c·ªßa ƒê·ªè (Ng∆∞·ªùi ch∆°i)',
                statusBlackTurn: 'L∆∞·ª£t c·ªßa ƒêen (M√°y t√≠nh)',
                winRed: 'ƒê·ªè (Ng∆∞·ªùi ch∆°i)',
                winBlack: 'ƒêen (M√°y t√≠nh)',
                winMessage: (winner) => `${winner} ƒë√£ th·∫Øng! Nh·∫•n Ch∆°i L·∫°i.`,
                drawMessage: 'H√≤a c·ªù. M√°y t√≠nh kh√¥ng c√≤n n∆∞·ªõc ƒëi.',
                // Modal ·ªßng h·ªô
                donateTitle: '·ª¶ng h·ªô Nh√† ph√°t tri·ªÉn',
                donateContent: (address) => `
                    <p class="mb-3">
                        ƒê·ªÉ ·ªßng h·ªô <b>1 Pi</b>, vui l√≤ng th·ª±c hi·ªán th·ªß c√¥ng c√°c b∆∞·ªõc sau:
                    </p>
                    <ol class="list-decimal list-inside space-y-2 text-left px-2">
                        <li>Nh·∫•n v√†o ƒë·ªãa ch·ªâ v√≠ ƒë·ªÉ <b>sao ch√©p</b>.</li>
                        <li>M·ªü Pi Wallet v√† d√°n ƒë·ªãa ch·ªâ ƒë√£ sao ch√©p.</li>
                        <li>Nh·∫≠p s·ªë l∆∞·ª£ng: <b>1 Pi</b>.</li>
                        <li>Nh·∫≠p Ghi ch√∫ (Memo): <b>·ª¶ng h·ªô game C·ªù T∆∞·ªõng</b> (T√πy ch·ªçn).</li>
                    </ol>
                    <p class="mt-4 mb-2 text-sm font-semibold">
                        ƒê·ªãa ch·ªâ V√≠ nh·∫≠n Pi (Nh·∫•p ƒë·ªÉ Sao ch√©p):
                    </p>
                    <div id="wallet-copy-area" 
                         class="wallet-address-copy bg-gray-100 p-3 rounded-lg text-xs font-mono break-all font-semibold text-green-700 hover:bg-gray-200 transition duration-150">
                        ${address}
                        <span class="copy-icon">üìã</span>
                    </div>
                `,
                donateButtonAction: 'M·ªü Pi Wallet (wallet.pinet.com)',
                copySuccess: 'ƒê√£ sao ch√©p! ‚úÖ',
            },
            'en': {
                gameTitle: 'Chinese Chess 2D',
                riverName: 'River (Chu River & Han Border)',
                resetButton: 'Reset Game',
                donateButton: 'Donate 1 Pi',
                modalTitle: 'Notification',
                closeButton: 'Close',
                restartConfirm: 'Do you want to restart the game with the new difficulty?', 
                // Add for Startup Modal
                startupTitle: 'Select Game Configuration',
                startGameButton: 'Start Game',
                diffLevel: 'AI Difficulty:',
                // Difficulty Levels
                diffEasy: 'Easy',
                diffMedium: 'Medium',
                diffHard: 'Hard',
                // Game status
                statusRedTurn: "Red's Turn (Player)",
                statusBlackTurn: "Black's Turn (AI)",
                winRed: 'Red (Player)',
                winBlack: 'Black (AI)',
                winMessage: (winner) => `${winner} wins! Click Reset Game.`,
                drawMessage: 'Draw. AI has no legal moves.',
                // Donate Modal
                donateTitle: 'Support the Developer',
                donateContent: (address) => `
                    <p class="mb-3">
                        To donate <b>1 Pi</b>, please follow these steps manually:
                    </p>
                    <ol class="list-decimal list-inside space-y-2 text-left px-2">
                        <li>Click the wallet address to <b>copy</b>.</li>
                        <li>Open Pi Wallet and paste the copied address.</li>
                        <li>Enter amount: <b>1 Pi</b>.</li>
                        <li>Enter Memo: <b>XianQi Game Support</b> (Optional).</li>
                    </ol>
                    <p class="mt-4 mb-2 text-sm font-semibold">
                        Recipient Pi Wallet Address (Click to Copy):
                    </p>
                    <div id="wallet-copy-area" 
                         class="wallet-address-copy bg-gray-100 p-3 rounded-lg text-xs font-mono break-all font-semibold text-green-700 hover:bg-gray-200 transition duration-150">
                        ${address}
                        <span class="copy-icon">üìã</span>
                    </div>
                `,
                donateButtonAction: 'Open Pi Wallet (wallet.pinet.com)',
                copySuccess: 'Copied! ‚úÖ',
            },
            'zh': {
                gameTitle: 'Ë±°Ê£ã 2D',
                riverName: 'Ê•öÊ≤≥Ê±âÁïå',
                resetButton: 'ÈáçÊñ∞ÂºÄÂßã',
                donateButton: 'ÊçêËµ† 1 Pi',
                modalTitle: 'ÈÄöÁü•',
                closeButton: 'ÂÖ≥Èó≠',
                restartConfirm: 'ÊÇ®ÊÉ≥Áî®Êñ∞ÁöÑÈöæÂ∫¶ÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÂêóÔºü', 
                // Add for Startup Modal
                startupTitle: 'ÈÄâÊã©Ê∏∏ÊàèÈÖçÁΩÆ',
                startGameButton: 'ÂºÄÂßãÊ∏∏Êàè',
                diffLevel: 'AI ÈöæÂ∫¶:',
                // Difficulty Levels
                diffEasy: 'ÁÆÄÂçï',
                diffMedium: '‰∏≠Á≠â',
                diffHard: 'Âõ∞Èöæ',
                // Game status
                statusRedTurn: 'Á∫¢ÊñπÂõûÂêà (Áé©ÂÆ∂)',
                statusBlackTurn: 'ÈªëÊñπÂõûÂêà (ÁîµËÑë)',
                winRed: 'Á∫¢Êñπ (Áé©ÂÆ∂)',
                winBlack: 'ÈªëÊñπ (ÁîµËÑë)',
                winMessage: (winner) => `${winner} Ëé∑ËÉú! ËØ∑ÁÇπÂáªÈáçÊñ∞ÂºÄÂßã„ÄÇ`,
                drawMessage: 'ÂíåÂ±Ä„ÄÇÁîµËÑëÊó†ÂêàÊ≥ïÊ£ãÊ≠•„ÄÇ',
                // Donate Modal
                donateTitle: 'ÊîØÊåÅÂºÄÂèëËÄÖ',
                donateContent: (address) => `
                    <p class="mb-3">
                        Ë¶ÅÊçêËµ† <b>1 Pi</b>, ËØ∑ÊâãÂä®ÈÅµÂæ™‰ª•‰∏ãÊ≠•È™§:
                    </p>
                    <ol class="list-decimal list-inside space-y-2 text-left px-2">
                        <li>ÁÇπÂáªÈí±ÂåÖÂú∞ÂùÄ‰ª•<b>Â§çÂà∂</b>„ÄÇ</li>
                        <li>ÊâìÂºÄ Pi Èí±ÂåÖÂπ∂Á≤òË¥¥Âú∞ÂùÄ„ÄÇ</li>
                        <li>ËæìÂÖ•Êï∞Èáè: <b>1 Pi</b>„ÄÇ</li>
                        <li>ËæìÂÖ•Â§áÊ≥®: <b>Ë±°Ê£ãÊ∏∏ÊàèÊîØÊåÅ</b> (ÂèØÈÄâ)„ÄÇ</li>
                    </ol>
                    <p class="mt-4 mb-2 text-sm font-semibold">
                        Êî∂Ê¨æ Pi Èí±ÂåÖÂú∞ÂùÄ (ÁÇπÂáªÂ§çÂà∂):
                    </p>
                    <div id="wallet-copy-area" 
                         class="wallet-address-copy bg-gray-100 p-3 rounded-lg text-xs font-mono break-all font-semibold text-green-700 hover:bg-gray-200 transition duration-150">
                        ${address}
                        <span class="copy-icon">üìã</span>
                    </div>
                `,
                donateButtonAction: 'ÊâìÂºÄ Pi Èí±ÂåÖ (wallet.pinet.com)',
                copySuccess: 'Â∑≤Â§çÂà∂! ‚úÖ',
            }
        };

        // Bi·∫øn ng√¥n ng·ªØ v√† c·∫•p ƒë·ªô kh√≥ hi·ªán t·∫°i
        let currentLang = localStorage.getItem('lang') || 'vi'; 
        let currentDifficulty = localStorage.getItem('difficulty') || 'medium'; 

        // H√†m d·ªãch thu·∫≠t
        const t = (key) => {
            const translation = translations[currentLang];
            if (translation && translation[key]) {
                return translation[key];
            }
            return translations['vi'][key] || key; 
        };
        
        // H√†m √°p d·ª•ng ng√¥n ng·ªØ
        const applyLanguage = (lang) => {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (key) {
                    element.textContent = t(key);
                }
            });

            if (currentPlayer === 'red') {
                updateStatus(t('statusRedTurn'), 'bg-red-100 text-red-700');
            } else {
                updateStatus(t('statusBlackTurn'), 'bg-gray-100 text-gray-700');
            }

            document.title = t('gameTitle');
        };

        const INITIAL_BOARD = [
            // ƒêen (Top)
            { piece: 'Xe', color: 'black', pos: 0 }, { piece: 'M√£', color: 'black', pos: 1 }, { piece: 'T∆∞·ª£ng', color: 'black', pos: 2 }, { piece: 'Sƒ©', color: 'black', pos: 3 }, { piece: 'T∆∞·ªõng', color: 'black', pos: 4 }, { piece: 'Sƒ©', color: 'black', pos: 5 }, { piece: 'T∆∞·ª£ng', color: 'black', pos: 6 }, { piece: 'M√£', color: 'black', pos: 7 }, { piece: 'Xe', color: 'black', pos: 8 },
            { piece: null, pos: 9 }, { piece: null, pos: 10 }, { piece: null, pos: 11 }, { piece: null, pos: 12 }, { piece: null, pos: 13 }, { piece: null, pos: 14 }, { piece: null, pos: 15 }, { piece: null, pos: 16 }, { piece: null, pos: 17 },
            { piece: null, pos: 18 }, { piece: 'Ph√°o', color: 'black', pos: 19 }, { piece: null, pos: 20 }, { piece: null, pos: 21 }, { piece: null, pos: 22 }, { piece: null, pos: 23 }, { piece: null, pos: 24 }, { piece: 'Ph√°o', color: 'black', pos: 25 }, { piece: null, pos: 26 },
            { piece: 'T·ªët', color: 'black', pos: 27 }, { piece: null, pos: 28 }, { piece: 'T·ªët', color: 'black', pos: 29 }, { piece: null, pos: 30 }, { piece: 'T·ªët', color: 'black', pos: 31 }, { piece: null, pos: 32 }, { piece: 'T·ªët', color: 'black', pos: 33 }, { piece: null, pos: 34 }, { piece: 'T·ªët', color: 'black', pos: 35 },
            // S√¥ng (36 -> 53)
            // H√†ng tr·ªëng (36 -> 44)
            // H√†ng tr·ªëng (45 -> 53)
            
            // ƒê·ªè (Bottom) - B·∫Øt ƒë·∫ßu t·ª´ 54
            { piece: 'T·ªët', color: 'red', pos: 54 }, { piece: null, pos: 55 }, { piece: 'T·ªët', color: 'red', pos: 56 }, { piece: null, pos: 57 }, { piece: 'T·ªët', color: 'red', pos: 58 }, { piece: null, pos: 59 }, { piece: 'T·ªët', color: 'red', pos: 60 }, { piece: null, pos: 61 }, { piece: 'T·ªët', color: 'red', pos: 62 },
            { piece: null, pos: 63 }, { piece: null, pos: 64 }, { piece: null, pos: 65 }, { piece: null, pos: 66 }, { piece: null, pos: 67 }, { piece: null, pos: 68 }, { piece: null, pos: 69 }, { piece: null, pos: 70 }, { piece: null, pos: 71 },
            { piece: null, pos: 72 }, { piece: 'Ph√°o', color: 'red', pos: 73 }, { piece: null, pos: 74 }, { piece: null, pos: 75 }, { piece: null, pos: 76 }, { piece: null, pos: 77 }, { piece: null, pos: 78 }, { piece: 'Ph√°o', color: 'red', pos: 79 }, { piece: null, pos: 80 },
            { piece: 'Xe', color: 'red', pos: 81 }, { piece: 'M√£', color: 'red', pos: 82 }, { piece: 'T∆∞·ª£ng', color: 'red', pos: 83 }, { piece: 'Sƒ©', color: 'red', pos: 84 }, { piece: 'T∆∞·ªõng', color: 'red', pos: 85 }, { piece: 'Sƒ©', color: 'red', pos: 86 }, { piece: 'T∆∞·ª£ng', color: 'red', pos: 87 }, { piece: 'M√£', color: 'red', pos: 88 }, { piece: 'Xe', color: 'red', pos: 89 }
        ].filter(p => p.piece !== null);
        
        const PIECE_NAMES = {
            // ƒêen (Truy·ªÅn th·ªëng)
            'T∆∞·ªõng': 'Â∞á', 'Sƒ©': 'Â£´', 'T∆∞·ª£ng': 'Ë±°', 'Xe': 'Ëªä', 'M√£': 'È¶¨', 'Ph√°o': 'ÁÇÆ', 'T·ªët': 'Âçí', 
            // ƒê·ªè (Hi·ªán ƒë·∫°i)
            'red': { 'T∆∞·ªõng': 'Â∏•', 'Sƒ©': '‰ªï', 'T∆∞·ª£ng': 'Áõ∏', 'Xe': '‰ø•', 'M√£': 'ÂÇå', 'Ph√°o': 'Á†≤', 'T·ªët': 'ÂÖµ' } 
        };

        // Gi√° tr·ªã qu√¢n c·ªù (d√πng cho thu·∫≠t to√°n AI)
        const PIECE_VALUES = {
            'T∆∞·ªõng': 100000, 
            'Xe': 900, 
            'Ph√°o': 450,
            'M√£': 400,
            'T∆∞·ª£ng': 200,
            'Sƒ©': 200,
            'T·ªët': 100 
        };
        
        let boardState = [];
        let selectedPiece = null;
        let currentPlayer = 'red';
        let isAITurn = false; 
        
        // ----------------------------------------------------
        // H√†m Utility
        // ----------------------------------------------------
        
        const copyToClipboard = (text) => {
            navigator.clipboard.writeText(text).then(() => {
                const targetButton = modalCustomButton.classList.contains('hidden') ? modalCloseButton : modalCustomButton;
                const originalContent = targetButton.textContent;
                const originalClass = targetButton.className;

                targetButton.textContent = t('copySuccess');
                targetButton.classList.remove('bg-indigo-500', 'bg-blue-500');
                targetButton.classList.add('bg-green-600');
                
                setTimeout(() => {
                    targetButton.textContent = originalContent;
                    targetButton.className = originalClass;
                }, 1500);
            }).catch(err => {
                console.error('Kh√¥ng th·ªÉ sao ch√©p', err);
            });
        };

        const displayMessage = (title, content, customButton) => {
            modalTitleElement.textContent = title;
            modalContentElement.innerHTML = content;
            modalElement.classList.add('active');
            modalElement.style.display = 'flex';
            
            modalCustomButton.onclick = null; 
            modalCustomButton.classList.add('hidden');

            if (customButton) {
                modalCustomButton.textContent = customButton.text;
                modalCustomButton.onclick = customButton.action;
                modalCustomButton.classList.remove('hidden');
                modalCustomButton.classList.add('bg-indigo-500', 'hover:bg-indigo-600');
                modalCustomButton.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            } else {
                modalCloseButton.classList.add('bg-blue-500', 'hover:bg-blue-600');
                modalCloseButton.classList.remove('bg-indigo-500', 'hover:bg-indigo-600');
            }
        };

        modalCloseButton.addEventListener('click', () => {
            modalElement.classList.remove('active');
            setTimeout(() => modalElement.style.display = 'none', 300);
        });

        // Chuy·ªÉn ƒë·ªïi ch·ªâ s·ªë 1D sang t·ªça ƒë·ªô (row, col)
        const toCoords = (pos) => ({ row: Math.floor(pos / 9), col: pos % 9 });
        // Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô (row, col) sang ch·ªâ s·ªë 1D
        const toPos = (row, col) => row * 9 + col;
        
        // L·∫•y qu√¢n c·ªù t·∫°i v·ªã tr√≠
        const getPieceAt = (pos, board = boardState) => board.find(p => p.pos === pos);

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i tr√≤ ch∆°i tr√™n UI
        const updateStatus = (message, colorClass) => {
            statusElement.textContent = message;
            statusElement.className = `text-sm sm:text-lg font-semibold mt-2 rounded-lg py-1 px-3 inline-block shadow-md ${colorClass}`;
        }
        
        // Hi·ªÉn th·ªã th√¥ng b√°o chi·∫øn th·∫Øng
        const showWinMessage = (winner) => {
            const winnerName = winner === 'red' ? t('winRed') : t('winBlack');
            const message = t('winMessage')(winnerName);
            updateStatus(message, winner === 'red' ? 'bg-red-200 text-red-800' : 'bg-gray-700 text-white');
            selectedPiece = true; 
        }

        // ƒê·ªïi l∆∞·ª£t ch∆°i v√† ki·ªÉm tra n·∫øu l√† l∆∞·ª£t AI
        const switchTurn = () => {
            currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
            const statusMessage = currentPlayer === 'red' ? t('statusRedTurn') : t('statusBlackTurn');
            const colorClass = currentPlayer === 'red' ? 'bg-red-100 text-red-700' : 'bg-gray-100 text-gray-700';
            updateStatus(statusMessage, colorClass);
            
            if (currentPlayer === 'black') {
                isAITurn = true;
                setTimeout(aiMove, 500); 
            }
        }

        // ----------------------------------------------------
        // Logic Ki·ªÉm tra Lu·∫≠t C·ªù 
        // ----------------------------------------------------

        const isInPalace = (row, col, color) => {
            const inPalaceCol = col >= 3 && col <= 5;
            if (color === 'red') {
                return inPalaceCol && row >= 7 && row <= 9; 
            } else {
                return inPalaceCol && row >= 0 && row <= 2; 
            }
        };

        const isPastRiver = (row, color) => {
            if (color === 'red') {
                return row <= 4; 
            } else {
                return row >= 5; 
            }
        };

        // H√†m ki·ªÉm tra ƒë∆∞·ªùng ƒëi cho XE
        const checkLine = (dR, dC, moves, enemyColor, startR, startC, currentBoard) => {
            for (let i = 1; ; i++) {
                const nextR = startR + dR * i;
                const nextC = startC + dC * i;
                const nextPos = toPos(nextR, nextC);
                if (nextR < 0 || nextR >= 10 || nextC < 0 || nextC >= 9) break;

                const targetPiece = getPieceAt(nextPos, currentBoard); 
                if (targetPiece) {
                    if (targetPiece.color === enemyColor) {
                        moves.push(nextPos); 
                    }
                    break; 
                }
                moves.push(nextPos); 
            }
        };
        
        // H√†m ki·ªÉm tra ƒë∆∞·ªùng ƒëi cho PH√ÅO
        const checkCannonLine = (dR, dC, moves, enemyColor, startR, startC, currentBoard) => {
            let screenFound = false; 
            for (let i = 1; ; i++) {
                const nextR = startR + dR * i;
                const nextC = startC + dC * i;
                const nextPos = toPos(nextR, nextC);
                if (nextR < 0 || nextR >= 10 || nextC < 0 || nextC >= 9) break;

                const targetPiece = getPieceAt(nextPos, currentBoard); 
                
                if (!targetPiece) {
                    if (!screenFound) {
                        moves.push(nextPos); 
                    }
                } else {
                    if (!screenFound) {
                        screenFound = true; 
                    } else {
                        if (targetPiece.color === enemyColor) {
                            moves.push(nextPos); 
                        }
                        break; 
                    }
                }
            }
        };

        // T√¨m t·∫•t c·∫£ c√°c n∆∞·ªõc ƒëi h·ª£p l·ªá cho qu√¢n c·ªù
        const getValidMoves = (piece, currentBoard = boardState) => {
            const { row: startR, col: startC } = toCoords(piece.pos);
            const moves = [];
            const color = piece.color;
            const enemyColor = color === 'red' ? 'black' : 'red';

            switch (piece.piece) {
                case 'T∆∞·ªõng':
                    [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => {
                        const nextR = startR + dr;
                        const nextC = startC + dc;
                        const nextPos = toPos(nextR, nextC);
                        const targetPiece = getPieceAt(nextPos, currentBoard); 

                        if (nextR >= 0 && nextR < 10 && nextC >= 0 && nextC < 9 && isInPalace(nextR, nextC, color)) {
                            if (!targetPiece || targetPiece.color === enemyColor) {
                                moves.push(nextPos);
                            }
                        }
                    });
                    break;
                case 'Sƒ©':
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => {
                        const nextR = startR + dr;
                        const nextC = startC + dc;
                        const nextPos = toPos(nextR, nextC);
                        const targetPiece = getPieceAt(nextPos, currentBoard); 

                        if (nextR >= 0 && nextR < 10 && nextC >= 0 && nextC < 9 && isInPalace(nextR, nextC, color)) {
                            if (!targetPiece || targetPiece.color === enemyColor) {
                                moves.push(nextPos);
                            }
                        }
                    });
                    break;
                case 'T∆∞·ª£ng':
                    [[2, 2], [2, -2], [-2, 2], [-2, -2]].forEach(([dr, dc]) => {
                        const nextR = startR + dr;
                        const nextC = startC + dc;
                        const nextPos = toPos(nextR, nextC);
                        const targetPiece = getPieceAt(nextPos, currentBoard); 
                        
                        const midR = startR + dr / 2;
                        const midC = startC + dc / 2;
                        const midPos = toPos(midR, midC);

                        if (nextR >= 0 && nextR < 10 && nextC >= 0 && nextC < 9 && (color === 'red' ? nextR >= 5 : nextR <= 4)) {
                            if (!getPieceAt(midPos, currentBoard) && (!targetPiece || targetPiece.color === enemyColor)) { 
                                moves.push(nextPos);
                            }
                        }
                    });
                    break;
                case 'Xe':
                    [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => checkLine(dr, dc, moves, enemyColor, startR, startC, currentBoard)); 
                    break;
                case 'Ph√°o':
                    [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => checkCannonLine(dr, dc, moves, enemyColor, startR, startC, currentBoard)); 
                    break;
                case 'M√£':
                    [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]].forEach(([dr, dc]) => {
                        const nextR = startR + dr;
                        const nextC = startC + dc;
                        const nextPos = toPos(nextR, nextC);
                        const targetPiece = getPieceAt(nextPos, currentBoard); 

                        if (nextR >= 0 && nextR < 10 && nextC >= 0 && nextC < 9) {
                            const midR = startR + (Math.abs(dr) > 1 ? Math.sign(dr) : 0);
                            const midC = startC + (Math.abs(dc) > 1 ? Math.sign(dc) : 0);
                            const midPos = toPos(midR, midC);
                            
                            if (!getPieceAt(midPos, currentBoard) && (!targetPiece || targetPiece.color === enemyColor)) { 
                                moves.push(nextPos);
                            }
                        }
                    });
                    break;
                case 'T·ªët':
                    let possibleMoves = [];
                    if (color === 'red') {
                        possibleMoves.push([-1, 0]); 
                        if (isPastRiver(startR, color)) {
                            possibleMoves.push([0, 1], [0, -1]); 
                        }
                    } else { 
                        possibleMoves.push([1, 0]); 
                        if (isPastRiver(startR, color)) {
                            possibleMoves.push([0, 1], [0, -1]); 
                        }
                    }

                    possibleMoves.forEach(([dr, dc]) => {
                        const nextR = startR + dr;
                        const nextC = startC + dc;
                        const nextPos = toPos(nextR, nextC);
                        const targetPiece = getPieceAt(nextPos, currentBoard); 

                        if (nextR >= 0 && nextR < 10 && nextC >= 0 && nextC < 9) {
                            if (!targetPiece || targetPiece.color === enemyColor) {
                                moves.push(nextPos);
                            }
                        }
                    });
                    break;
            }

            return moves;
        };

        // ----------------------------------------------------
        // Logic AI C·∫•p ƒê·ªô Kh√≥ 
        // ----------------------------------------------------

        // H√†m m√¥ ph·ªèng n∆∞·ªõc ƒëi v√† t·∫°o ra tr·∫°ng th√°i b√†n c·ªù m·ªõi (Immutable)
        const simulateMove = (board, piece, targetPos) => {
            // L·ªçc ra qu√¢n b·ªã ƒÉn (n·∫øu c√≥) v√† qu√¢n ƒëang di chuy·ªÉn
            let newBoard = board.filter(p => p.pos !== targetPos && p.pos !== piece.pos).map(p => ({ ...p }));
            
            // Clone qu√¢n ƒëang di chuy·ªÉn v√† c·∫≠p nh·∫≠t v·ªã tr√≠ m·ªõi
            const newPiece = { ...piece, pos: targetPos };
            newBoard.push(newPiece);
            return newBoard;
        };

        // H√†m ƒë√°nh gi√° tr·∫°ng th√°i b√†n c·ªù
        const evaluateBoard = (board, maximizingColor) => {
            let score = 0;
            
            board.forEach(piece => {
                let value = PIECE_VALUES[piece.piece] || 0;
                
                // ƒêi·ªÅu ch·ªânh gi√° tr·ªã T·ªët n·∫øu qua s√¥ng
                if (piece.piece === 'T·ªët') {
                    const { row } = toCoords(piece.pos);
                    const isT·ªëtPastRiver = isPastRiver(row, piece.color);
                    if (isT·ªëtPastRiver) {
                        value *= 2; 
                    }
                }
                
                // C·ªông ƒëi·ªÉm n·∫øu l√† qu√¢n c·ªßa ng∆∞·ªùi ch∆°i t·ªëi ∆∞u h√≥a, tr·ª´ ƒëi·ªÉm n·∫øu l√† qu√¢n ƒë·ªãch
                if (piece.color === maximizingColor) {
                    score += value;
                } else {
                    score -= value;
                }
            });
            
            return score;
        };
        
        // H√†m t√¨m t·∫•t c·∫£ n∆∞·ªõc ƒëi h·ª£p l·ªá cho m·ªôt m√†u tr√™n m·ªôt b√†n c·ªù
        const getAllLegalMoves = (board, color) => {
            let allMoves = [];
            const pieces = board.filter(p => p.color === color);
            
            for (const piece of pieces) {
                const validMoves = getValidMoves(piece, board);
                validMoves.forEach(targetPos => allMoves.push({ piece, targetPos }));
            }
            return allMoves;
        };

        // Thu·∫≠t to√°n t√¨m ki·∫øm n∆∞·ªõc ƒëi t·ªët nh·∫•t (Minimax - ƒê∆°n gi·∫£n)
        const findBestMove = (board, playerColor, depth) => {
            const moves = getAllLegalMoves(board, playerColor);
            if (moves.length === 0) return null;
            
            if (depth === 1) { // Medium Difficulty (Greedy - 1-ply Lookahead)
                let bestScore = -Infinity;
                let bestMove = null;

                for (const move of moves) {
                    const newBoard = simulateMove(board, move.piece, move.targetPos);
                    const score = evaluateBoard(newBoard, playerColor);

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return bestMove;
                
            } else if (depth >= 2) { // Hard Difficulty (Simplified Minimax - 2-ply Lookahead)
                let bestScore = -Infinity;
                let bestMove = null;
                const opponentColor = playerColor === 'black' ? 'red' : 'black';
                
                for (const aiMove of moves) {
                    const boardAfterAI = simulateMove(board, aiMove.piece, aiMove.targetPos);
                    
                    // Giai ƒëo·∫°n 2: Gi·∫£ ƒë·ªãnh ƒë·ªëi th·ªß ch·ªçn n∆∞·ªõc ƒëi t·ªët nh·∫•t cho h·ªç (t·ªëi thi·ªÉu h√≥a ƒëi·ªÉm AI)
                    const opponentMoves = getAllLegalMoves(boardAfterAI, opponentColor);
                    let minOpponentScore = Infinity; // T√¨m ƒëi·ªÉm t·ªëi thi·ªÉu nh·∫•t cho AI

                    if (opponentMoves.length > 0) {
                        for (const opponentMove of opponentMoves) {
                            const boardAfterOpponent = simulateMove(boardAfterAI, opponentMove.piece, opponentMove.targetPos);
                            
                            // ƒê√°nh gi√° tr·∫°ng th√°i cu·ªëi c√πng t·ª´ g√≥c nh√¨n c·ªßa AI
                            const score = evaluateBoard(boardAfterOpponent, playerColor); 
                            minOpponentScore = Math.min(minOpponentScore, score);
                        }
                    } else {
                        // N·∫øu ƒë·ªëi th·ªß kh√¥ng c√≥ n∆∞·ªõc ƒëi (c√≥ th·ªÉ l√† chi·∫øu b√≠ ho·∫∑c h√≤a), d√πng ƒëi·ªÉm tr·∫°ng th√°i hi·ªán t·∫°i
                        minOpponentScore = evaluateBoard(boardAfterAI, playerColor);
                    }
                    
                    // So s√°nh ƒëi·ªÉm t·ªëi thi·ªÉu m√† AI nh·∫≠n ƒë∆∞·ª£c sau n∆∞·ªõc ƒëi c·ªßa ƒë·ªëi th·ªß
                    if (minOpponentScore > bestScore) {
                        bestScore = minOpponentScore;
                        bestMove = aiMove;
                    }
                }
                return bestMove;
            }
            
            return null;
        };

        // ----------------------------------------------------
        // Logic AI ƒêen (M√°y t√≠nh)
        // ----------------------------------------------------

        const aiMove = () => {
            if (currentPlayer !== 'black') return;

            isAITurn = true; 
            let moveSet = [];
            let bestMove = null;
            
            if (currentDifficulty === 'easy') {
                // Easy: ∆Øu ti√™n b·∫Øt T∆∞·ªõng > b·∫Øt qu√¢n kh√°c > ng·∫´u nhi√™n
                let allLegalMoves = getAllLegalMoves(boardState, 'black');
                let generalCaptureMoves = allLegalMoves.filter(move => getPieceAt(move.targetPos)?.piece === 'T∆∞·ªõng');
                let capturingMoves = allLegalMoves.filter(move => getPieceAt(move.targetPos) && getPieceAt(move.targetPos).piece !== 'T∆∞·ªõng');
                
                if (generalCaptureMoves.length > 0) {
                    moveSet = generalCaptureMoves;
                } else if (capturingMoves.length > 0) {
                    moveSet = capturingMoves;
                } else {
                    moveSet = allLegalMoves;
                }

                if (moveSet.length === 0) {
                    updateStatus(t('drawMessage'), 'bg-yellow-200 text-yellow-800');
                    isAITurn = false;
                    selectedPiece = true; 
                    return;
                }
                // Ch·ªçn ng·∫´u nhi√™n t·ª´ b·ªô n∆∞·ªõc ƒëi ∆∞u ti√™n
                const randomIndex = Math.floor(Math.random() * moveSet.length);
                bestMove = moveSet[randomIndex];

            } else if (currentDifficulty === 'medium') {
                // Medium: 1-ply Lookahead (Greedy)
                bestMove = findBestMove(boardState, 'black', 1);

            } else if (currentDifficulty === 'hard') {
                // Hard: 2-ply Lookahead (Simplified Minimax)
                bestMove = findBestMove(boardState, 'black', 2);
            }
            
            if (!bestMove) {
                updateStatus(t('drawMessage'), 'bg-yellow-200 text-yellow-800');
                isAITurn = false;
                selectedPiece = true; 
                return;
            }
            
            const { piece: pieceToMove, targetPos } = bestMove;
            const capturedPiece = getPieceAt(targetPos);

            // 4. Th·ª±c hi·ªán n∆∞·ªõc ƒëi
            if (capturedPiece && capturedPiece.piece === 'T∆∞·ªõng') {
                boardState = boardState.filter(p => p.pos !== targetPos); 
                pieceToMove.pos = targetPos; 
                boardState = boardState.filter(p => p !== pieceToMove);
                boardState.push(pieceToMove);

                renderBoard();
                showWinMessage('black');
                isAITurn = false;
                return;
            }

            // Di chuy·ªÉn/ƒÇn qu√¢n (kh√¥ng ph·∫£i T∆∞·ªõng)
            boardState = boardState.filter(p => p.pos !== targetPos && p.pos !== pieceToMove.pos);
            pieceToMove.pos = targetPos;
            boardState.push(pieceToMove);

            isAITurn = false;
            selectedPiece = null;
            renderBoard();
            switchTurn();
        };


        // ----------------------------------------------------
        // Logic ·ª¶ng h·ªô
        // ----------------------------------------------------

        const initiatePiPayment = () => {
            const content = t('donateContent')(PI_WALLET_ADDRESS);
            
            const customButton = {
                text: t('donateButtonAction'),
                action: () => {
                    window.open('https://wallet.pinet.com/', '_blank');
                    modalCloseButton.click(); 
                }
            };

            displayMessage(t('donateTitle'), content, customButton);
            
            setTimeout(() => {
                const copyArea = document.getElementById('wallet-copy-area');
                if (copyArea) {
                    copyArea.onclick = () => {
                        copyToClipboard(PI_WALLET_ADDRESS);
                        copyArea.querySelector('.copy-icon').textContent = '‚úÖ';
                        setTimeout(() => {
                            copyArea.querySelector('.copy-icon').textContent = 'üìã';
                        }, 1500);
                    };
                }
            }, 100); 
        };


        // ----------------------------------------------------
        // Logic Kh·ªüi ƒë·ªông & Reset Game
        // ----------------------------------------------------

        // H√†m Reset Game (Kh·ªüi t·∫°o l·∫°i b√†n c·ªù)
        const resetGame = () => {
            boardState = INITIAL_BOARD.map(p => ({ ...p }));
            selectedPiece = null;
            currentPlayer = 'red';
            isAITurn = false;
            
            // T·∫£i l·∫°i ng√¥n ng·ªØ v√† tr·∫°ng th√°i
            applyLanguage(currentLang); 
            updateStatus(t('statusRedTurn'), 'bg-red-100 text-red-700');
            renderBoard();
        };

        // H√†m hi·ªÉn th·ªã Modal Kh·ªüi ƒë·ªông
        const showStartupModal = () => {
            const langOptions = `
                <label class="block text-sm font-medium text-gray-700 mb-1" id="lang-label">Ng√¥n ng·ªØ:</label>
                <select id="startup-language-select" class="p-2 border border-gray-300 rounded text-sm bg-white shadow-sm w-full mb-4">
                    <option value="vi">üáªüá≥ Ti·∫øng Vi·ªát</option>
                    <option value="en">üá∫üá∏ English</option>
                    <option value="zh">üá®üá≥ ‰∏≠Êñá (Simplified)</option>
                </select>
            `;
            
            const diffOptions = `
                <label class="block text-sm font-medium text-gray-700 mb-1" id="diff-label" data-i18n-startup-label="diffLevel">ƒê·ªô kh√≥ AI:</label>
                <select id="startup-difficulty-select" class="p-2 border border-gray-300 rounded text-sm bg-white shadow-sm w-full">
                    <option value="easy" data-i18n-start="diffEasy">D·ªÖ</option>
                    <option value="medium" data-i18n-start="diffMedium">Trung b√¨nh</option>
                    <option value="hard" data-i18n-start="diffHard">Kh√≥</option>
                </select>
            `;

            const content = `<div class="p-2">${langOptions}${diffOptions}</div>`;

            // Hi·ªÉn th·ªã modal. N√∫t ƒê√≥ng s·∫Ω ƒë∆∞·ª£c thay b·∫±ng n√∫t B·∫Øt ƒê·∫ßu Ch∆°i
            displayMessage(t('startupTitle'), content, {
                text: t('startGameButton'),
                action: () => {
                    const newLang = document.getElementById('startup-language-select').value;
                    const newDifficulty = document.getElementById('startup-difficulty-select').value;

                    currentLang = newLang;
                    currentDifficulty = newDifficulty;
                    localStorage.setItem('lang', newLang);
                    localStorage.setItem('difficulty', newDifficulty);
                    
                    applyLanguage(currentLang); 
                    resetGame(); 
                    modalCloseButton.click();
                }
            });
            
            // ·∫®n n√∫t "ƒê√≥ng" m·∫∑c ƒë·ªãnh
            modalCloseButton.classList.add('hidden');
            
            // Thi·∫øt l·∫≠p gi√° tr·ªã ban ƒë·∫ßu v√† d·ªãch thu·∫≠t trong modal
            setTimeout(() => {
                const langSelect = document.getElementById('startup-language-select');
                const diffSelect = document.getElementById('startup-difficulty-select');
                
                // S·ª≠ d·ª•ng gi√° tr·ªã ƒë√£ l∆∞u
                if (langSelect) langSelect.value = localStorage.getItem('lang') || 'vi';
                if (diffSelect) diffSelect.value = localStorage.getItem('difficulty') || 'medium';

                // D·ªãch nh√£n v√† t√πy ch·ªçn ƒë·ªô kh√≥
                document.getElementById('diff-label').textContent = t('diffLevel');
                document.querySelectorAll('[data-i18n-start]').forEach(element => {
                    const key = element.getAttribute('data-i18n-start');
                    element.textContent = t(key);
                });
                
            }, 50);
        };

        // H√†m kh·ªüi t·∫°o game (ƒëi·ªÉm v√†o ch√≠nh)
        const initializeGame = () => {
            // T·∫£i ng√¥n ng·ªØ v√† c·∫•p ƒë·ªô kh√≥ ban ƒë·∫ßu t·ª´ localStorage
            currentLang = localStorage.getItem('lang') || 'vi'; 
            currentDifficulty = localStorage.getItem('difficulty') || 'medium'; 
            
            // √Åp d·ª•ng ng√¥n ng·ªØ ban ƒë·∫ßu ƒë·ªÉ hi·ªÉn th·ªã UI v√† Modal
            applyLanguage(currentLang);
            
            // Hi·ªÉn th·ªã modal tr∆∞·ªõc khi game b·∫Øt ƒë·∫ßu
            showStartupModal(); 
            
            // G·∫Øn s·ª± ki·ªán cho n√∫t ch∆°i l·∫°i (reset button)
            resetButton.addEventListener('click', () => {
                // Hi·ªán l·∫°i modal c·∫•u h√¨nh ƒë·ªÉ ng∆∞·ªùi ch∆°i c√≥ th·ªÉ thay ƒë·ªïi ƒë·ªô kh√≥/ng√¥n ng·ªØ
                showStartupModal();
            });
            
            // G·∫Øn s·ª± ki·ªán cho n√∫t ·ªßng h·ªô
            donateButton.addEventListener('click', initiatePiPayment);
        };

        // ----------------------------------------------------
        // X·ª≠ l√Ω Giao di·ªán v√† S·ª± ki·ªán 
        // ----------------------------------------------------

        const renderBoard = () => {
            boardElement.querySelectorAll('.square').forEach(sq => sq.remove());
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                const square = document.createElement('div');
                square.className = 'square';
                square.dataset.pos = i;
                square.addEventListener('click', handleSquareClick);
                
                const pieceData = getPieceAt(i);
                if (pieceData) {
                    const pieceElement = document.createElement('div');
                    const pieceName = pieceData.color === 'red' 
                        ? PIECE_NAMES.red[pieceData.piece] 
                        : PIECE_NAMES[pieceData.piece];
                    
                    pieceElement.textContent = pieceName;
                    pieceElement.className = `piece ${pieceData.color}`;
                    pieceElement.dataset.piece = pieceData.piece;
                    pieceElement.dataset.color = pieceData.color;
                    
                    square.appendChild(pieceElement);
                    
                    if (selectedPiece && selectedPiece.pos === i) {
                        pieceElement.classList.add('selected');
                    }
                }
                
                boardElement.appendChild(square);
            }

            if (selectedPiece && !isAITurn) {
                const validMoves = getValidMoves(selectedPiece);
                validMoves.forEach(pos => {
                    const square = boardElement.querySelector(`[data-pos="${pos}"]`);
                    if (square) {
                        square.classList.add('highlight-move');
                    }
                });
            }
            
            const river = boardElement.querySelector('.river');
            if (river) boardElement.appendChild(river);
        };

        const handleSquareClick = (event) => {
            if (currentPlayer !== 'red' || isAITurn || selectedPiece === true) return;
            
            const squareElement = event.currentTarget;
            const pos = parseInt(squareElement.dataset.pos);
            const pieceAtPos = getPieceAt(pos);

            if (!selectedPiece) {
                if (pieceAtPos && pieceAtPos.color === currentPlayer) {
                    selectedPiece = pieceAtPos;
                    renderBoard(); 
                }
                return;
            }

            const validMoves = getValidMoves(selectedPiece);
            
            if (pieceAtPos && pieceAtPos.color === currentPlayer) {
                selectedPiece = pieceAtPos; 
                renderBoard();
                return;
            }

            if (validMoves.includes(pos)) {
                
                if (pieceAtPos && pieceAtPos.piece === 'T∆∞·ªõng') {
                    boardState = boardState.filter(p => p.pos !== pos); 
                    selectedPiece.pos = pos;
                    
                    boardState = boardState.filter(p => p !== selectedPiece);
                    boardState.push(selectedPiece);
                    
                    renderBoard();
                    showWinMessage(currentPlayer);
                    return;
                }

                boardState = boardState.filter(p => p.pos !== pos && p.pos !== selectedPiece.pos);
                selectedPiece.pos = pos;
                boardState.push(selectedPiece);
                
                selectedPiece = null;
                renderBoard();
                switchTurn();

            } else {
                selectedPiece = null;
                renderBoard();
            }
        };

        // Ch·∫°y l·∫ßn ƒë·∫ßu
        window.onload = initializeGame;

    </script>
</body>
</html>
